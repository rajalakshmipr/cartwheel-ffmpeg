From 936d73d3eb74f0a9e29614ed0bb6de46a30f0d4d Mon Sep 17 00:00:00 2001
From: Tong Wu <tong1.wu@intel.com>
Date: Mon, 4 Jul 2022 16:09:55 +0800
Subject: [PATCH 1/3] lavfi/avfiltergraph: move convert codes into functions

This patch moves the auto-insert filter codes into two functions.

Signed-off-by: Tong Wu <tong1.wu@intel.com>
---
 libavfilter/avfiltergraph.c | 168 +++++++++++++++++++++---------------
 1 file changed, 98 insertions(+), 70 deletions(-)

diff --git a/libavfilter/avfiltergraph.c b/libavfilter/avfiltergraph.c
index 4c80204f01..632eccdd84 100644
--- a/libavfilter/avfiltergraph.c
+++ b/libavfilter/avfiltergraph.c
@@ -499,6 +499,98 @@ static void print_filter_formats(void *log_ctx, int level, const AVFilterContext
     }
 }
 
+static int insert_auto_filter(AVFilterContext **convert, AVFilterGraph *graph,
+                              AVFilterLink *link, const char *filter_name,
+                              const char *filter_opts, int *converter_count, void *log_ctx)
+{
+    int ret;
+    const AVFilter *filter;
+    AVFilterContext *ctx;
+    char inst_name[30];
+
+    if (!(filter = avfilter_get_by_name(filter_name))) {
+        av_log(log_ctx, AV_LOG_ERROR,
+               "'%s' filter not present, cannot convert formats.\n",
+               filter_name);
+        print_link_formats(log_ctx, AV_LOG_ERROR, link);
+        return AVERROR(EINVAL);
+    }
+    snprintf(inst_name, sizeof(inst_name), "auto_%s_%d",
+             filter_name, (*converter_count)++);
+    ret = avfilter_graph_create_filter(&ctx, filter, inst_name, filter_opts, NULL, graph);
+    if (ret < 0)
+        return ret;
+
+    if ((ret = avfilter_insert_filter(link, ctx, 0, 0)) < 0)
+        return ret;
+
+    if ((ret = filter_query_formats(ctx)) < 0)
+        return ret;
+
+    *convert = ctx;
+    return 0;
+}
+
+static int merge_auto_filter(AVFilterContext *convert, const AVFilterNegotiation *neg,
+                             const char *filter_name, void *log_ctx)
+{
+    int ret;
+    AVFilterLink *inlink  = convert->inputs[0];
+    AVFilterLink *outlink = convert->outputs[0];
+    unsigned neg_step;
+
+    /* Assertions for format refcounts */
+    av_assert0( inlink->incfg.formats->refcount > 0);
+    av_assert0( inlink->outcfg.formats->refcount > 0);
+    av_assert0(outlink->incfg.formats->refcount > 0);
+    av_assert0(outlink->outcfg.formats->refcount > 0);
+    if (outlink->type == AVMEDIA_TYPE_VIDEO) {
+        av_assert0( inlink-> incfg.color_spaces->refcount > 0);
+        av_assert0( inlink->outcfg.color_spaces->refcount > 0);
+        av_assert0(outlink-> incfg.color_spaces->refcount > 0);
+        av_assert0(outlink->outcfg.color_spaces->refcount > 0);
+        av_assert0( inlink-> incfg.color_ranges->refcount > 0);
+        av_assert0( inlink->outcfg.color_ranges->refcount > 0);
+        av_assert0(outlink-> incfg.color_ranges->refcount > 0);
+        av_assert0(outlink->outcfg.color_ranges->refcount > 0);
+        av_assert0( inlink-> incfg.alpha_modes->refcount > 0);
+        av_assert0( inlink->outcfg.alpha_modes->refcount > 0);
+        av_assert0(outlink-> incfg.alpha_modes->refcount > 0);
+        av_assert0(outlink->outcfg.alpha_modes->refcount > 0);
+    } else if (outlink->type == AVMEDIA_TYPE_AUDIO) {
+        av_assert0( inlink-> incfg.samplerates->refcount > 0);
+        av_assert0( inlink->outcfg.samplerates->refcount > 0);
+        av_assert0(outlink-> incfg.samplerates->refcount > 0);
+        av_assert0(outlink->outcfg.samplerates->refcount > 0);
+        av_assert0( inlink-> incfg.channel_layouts->refcount > 0);
+        av_assert0( inlink->outcfg.channel_layouts->refcount > 0);
+        av_assert0(outlink-> incfg.channel_layouts->refcount > 0);
+        av_assert0(outlink->outcfg.channel_layouts->refcount > 0);
+    }
+
+#define MERGE(merger, link)                                                  \
+    ((merger)->merge(FF_FIELD_AT(void *, (merger)->offset, (link)->incfg),   \
+                     FF_FIELD_AT(void *, (merger)->offset, (link)->outcfg)))
+
+    for (neg_step = 0; neg_step < neg->nb_mergers; neg_step++) {
+        const AVFilterFormatsMerger *m = &neg->mergers[neg_step];
+        if (m->conversion_filter != filter_name)
+            continue;
+        if ((ret = MERGE(m,  inlink)) <= 0 ||
+            (ret = MERGE(m, outlink)) <= 0) {
+            if (ret < 0)
+                return ret;
+            av_log(log_ctx, AV_LOG_ERROR,
+                   "Impossible to convert between the formats supported by the filter "
+                   "'%s' and the filter '%s'\n", inlink->src->name, outlink->dst->name);
+            print_link_formats(log_ctx, AV_LOG_ERROR, inlink);
+            return AVERROR(ENOSYS);
+        }
+    }
+    return 2; /* indicate successful merge for 2 links (inlink and outlink) */
+}
+
+
 /**
  * Perform one round of query_formats() and merging formats lists on the
  * filter graph.
@@ -595,9 +687,6 @@ retry:
              * of mergers, since they are prepended onto the existing link
              */
             for (k = num_conv - 1; k >= 0; k--) {
-                const AVFilter *filter;
-                char inst_name[30];
-
                 if (fffiltergraph(graph)->disable_auto_convert) {
                     av_log(log_ctx, AV_LOG_ERROR,
                            "The filters '%s' and '%s' do not have a common format "
@@ -607,79 +696,18 @@ retry:
                     return AVERROR(EINVAL);
                 }
 
-                if (!(filter = avfilter_get_by_name(conv_filters[k]))) {
-                    av_log(log_ctx, AV_LOG_ERROR,
-                           "'%s' filter not present, cannot convert formats.\n",
-                           conv_filters[k]);
-                    print_link_formats(log_ctx, AV_LOG_ERROR, link);
-                    return AVERROR(EINVAL);
-                }
-                snprintf(inst_name, sizeof(inst_name), "auto_%s_%d",
-                         conv_filters[k], converter_count++);
-                ret = avfilter_graph_create_filter(&conv[k], filter, inst_name,
-                                                   conv_opts[k], NULL, graph);
+                ret = insert_auto_filter(&conv[k], graph, link, conv_filters[k],
+                                         conv_opts[k], &converter_count, log_ctx);
                 if (ret < 0)
                     return ret;
-                if ((ret = avfilter_insert_filter(link, conv[k], 0, 0)) < 0)
-                    return ret;
-
-                if ((ret = filter_query_formats(conv[k])) < 0)
-                    return ret;
             }
 
             /* preemptively settle formats of auto filters */
             for (k = 0; k < num_conv; k++) {
-                AVFilterLink *inlink  = conv[k]->inputs[0];
-                AVFilterLink *outlink = conv[k]->outputs[0];
-                av_assert0( inlink->incfg.formats->refcount > 0);
-                av_assert0( inlink->outcfg.formats->refcount > 0);
-                av_assert0(outlink->incfg.formats->refcount > 0);
-                av_assert0(outlink->outcfg.formats->refcount > 0);
-                if (outlink->type == AVMEDIA_TYPE_VIDEO) {
-                    av_assert0( inlink-> incfg.color_spaces->refcount > 0);
-                    av_assert0( inlink->outcfg.color_spaces->refcount > 0);
-                    av_assert0(outlink-> incfg.color_spaces->refcount > 0);
-                    av_assert0(outlink->outcfg.color_spaces->refcount > 0);
-                    av_assert0( inlink-> incfg.color_ranges->refcount > 0);
-                    av_assert0( inlink->outcfg.color_ranges->refcount > 0);
-                    av_assert0(outlink-> incfg.color_ranges->refcount > 0);
-                    av_assert0(outlink->outcfg.color_ranges->refcount > 0);
-                    av_assert0( inlink-> incfg.alpha_modes->refcount > 0);
-                    av_assert0( inlink->outcfg.alpha_modes->refcount > 0);
-                    av_assert0(outlink-> incfg.alpha_modes->refcount > 0);
-                    av_assert0(outlink->outcfg.alpha_modes->refcount > 0);
-                } else if (outlink->type == AVMEDIA_TYPE_AUDIO) {
-                    av_assert0( inlink-> incfg.samplerates->refcount > 0);
-                    av_assert0( inlink->outcfg.samplerates->refcount > 0);
-                    av_assert0(outlink-> incfg.samplerates->refcount > 0);
-                    av_assert0(outlink->outcfg.samplerates->refcount > 0);
-                    av_assert0( inlink-> incfg.channel_layouts->refcount > 0);
-                    av_assert0( inlink->outcfg.channel_layouts->refcount > 0);
-                    av_assert0(outlink-> incfg.channel_layouts->refcount > 0);
-                    av_assert0(outlink->outcfg.channel_layouts->refcount > 0);
-                }
-
-#define MERGE(merger, link)                                                  \
-    ((merger)->merge(FF_FIELD_AT(void *, (merger)->offset, (link)->incfg),   \
-                     FF_FIELD_AT(void *, (merger)->offset, (link)->outcfg)))
-
-                for (neg_step = 0; neg_step < neg->nb_mergers; neg_step++) {
-                    const AVFilterFormatsMerger *m = &neg->mergers[neg_step];
-                    if (m->conversion_filter != conv_filters[k])
-                        continue;
-                    if ((ret = MERGE(m,  inlink)) <= 0 ||
-                        (ret = MERGE(m, outlink)) <= 0) {
-                        if (ret < 0)
-                            return ret;
-                        av_log(log_ctx, AV_LOG_ERROR,
-                               "Impossible to convert between the formats supported by the filter "
-                               "'%s' and the filter '%s'\n", link->src->name, link->dst->name);
-                        print_link_formats(log_ctx, AV_LOG_ERROR, link);
-                        return AVERROR(ENOSYS);
-                    } else {
-                        count_merged += 2;
-                    }
-                }
+                ret = merge_auto_filter(conv[k], neg, conv_filters[k], log_ctx);
+                if (ret < 0)
+                    return ret;
+                count_merged += ret;
             }
 
             /* if there is more than one auto filter, we may need another round
-- 
2.41.0.windows.1

