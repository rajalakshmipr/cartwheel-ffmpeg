From 4ef205c08d0550b1ede57585d5af68c6b8829bc8 Mon Sep 17 00:00:00 2001
From: Tong Wu <tong1.wu@intel.com>
Date: Mon, 4 Jul 2022 16:09:56 +0800
Subject: [PATCH 2/3] lavfi/format: wrap auto filters into structures

This patch wraps auto conversion filters into new structures, making it
easier to add more auto filters. And it adds a loop to automatically insert
every possible conversion filter until merge succeeds.

Signed-off-by: Tong Wu <tong1.wu@intel.com>
---
 libavfilter/avfiltergraph.c | 97 +++++++++++++++++++++++--------------
 libavfilter/formats.c       | 18 +++++++
 libavfilter/formats.h       |  7 +++
 3 files changed, 85 insertions(+), 37 deletions(-)

diff --git a/libavfilter/avfiltergraph.c b/libavfilter/avfiltergraph.c
index f029ac5c88..a3163a0033 100644
--- a/libavfilter/avfiltergraph.c
+++ b/libavfilter/avfiltergraph.c
@@ -444,24 +444,24 @@ static int formats_declared(AVFilterContext *f)
 }
 
 static int insert_auto_filter(AVFilterContext **convert, AVFilterGraph *graph,
-                              AVFilterLink *link, const char *filter_name,
-                              const char *filter_opts, int *converter_count, void *log_ctx)
+                              AVFilterLink *link, const AVFilterNegotiation *neg,
+                              unsigned conv_step, int *converter_count, void *log_ctx)
 {
     int ret;
     const AVFilter *filter;
     AVFilterContext *ctx;
     char inst_name[30];
+    const char *opts = FF_FIELD_AT(char *, neg->conversion_filters[conv_step].conversion_opts_offset, *graph);
+    const char *name = neg->conversion_filters[conv_step].conversion_filter;
 
-    if (!(filter = avfilter_get_by_name(filter_name))) {
+    if (!(filter = avfilter_get_by_name(name))) {
         av_log(log_ctx, AV_LOG_ERROR,
-               "'%s' filter not present, cannot convert formats.\n",
-               filter_name);
+               "'%s' filter not present, cannot convert formats.\n", name);
         print_link_formats(log_ctx, AV_LOG_ERROR, link);
         return AVERROR(EINVAL);
     }
-    snprintf(inst_name, sizeof(inst_name), "auto_%s_%d",
-             filter_name, (*converter_count)++);
-    ret = avfilter_graph_create_filter(&ctx, filter, inst_name, filter_opts, NULL, graph);
+    snprintf(inst_name, sizeof(inst_name), "auto_%s_%d", name, (*converter_count)++);
+    ret = avfilter_graph_create_filter(&ctx, filter, inst_name, opts, NULL, graph);
     if (ret < 0)
         return ret;
 
@@ -631,8 +631,6 @@ retry:
         for (j = 0; j < filter->nb_inputs; j++) {
             AVFilterLink *link = filter->inputs[j];
             const AVFilterNegotiation *neg;
-            AVFilterContext *conv[4];
-            const char *conv_filters[4], *conv_opts[4] = {0};
             unsigned neg_step, num_conv = 0;
 
             if (!link)
@@ -672,20 +670,14 @@ retry:
                     if (ret < 0)
                         return ret;
                     if (!ret) {
-                        conv_filters[num_conv] = m->conversion_filter;
-                        if (m->conversion_opts_offset)
-                            conv_opts[num_conv] = FF_FIELD_AT(char *, m->conversion_opts_offset, *graph);
-                        num_conv++;
+                        num_conv = 1; /* conversion needed */
                     }
                 }
             }
 
-            /**
-             * Couldn't merge format lists; auto-insert conversion filters
-             * in reverse order to keep the order consistent with the list
-             * of mergers, since they are prepended onto the existing link
-             */
-            for (k = num_conv - 1; k >= 0; k--) {
+            if (num_conv) {
+                unsigned conv_step;
+                
                 if (fffiltergraph(graph)->disable_auto_convert) {
                     av_log(log_ctx, AV_LOG_ERROR,
                            "The filters '%s' and '%s' do not have a common format "
@@ -695,25 +687,56 @@ retry:
                     return AVERROR(EINVAL);
                 }
 
-                ret = insert_auto_filter(&conv[k], graph, link, conv_filters[k],
-                                         conv_opts[k], &converter_count, log_ctx);
-                if (ret < 0)
-                    return ret;
-            }
+                /* couldn't merge format lists. auto-insert conversion filter */
+                for (conv_step = 0; conv_step < neg->nb_conversion_filters; conv_step++) {
+                    AVFilterContext *convert;
+                    ret = insert_auto_filter(&convert, graph, link, neg,
+                                             conv_step, &converter_count, log_ctx);
+                    if (ret < 0) {
+                        av_log(log_ctx, AV_LOG_ERROR, "Failed to insert an auto filter.\n");
+                        return ret;
+                    }
 
-            /* preemptively settle formats of auto filters */
-            for (k = 0; k < num_conv; k++) {
-                ret = merge_auto_filter(conv[k], neg, conv_filters[k], log_ctx);
-                if (ret < 0)
-                    return ret;
-                count_merged += ret;
+                    ret = merge_auto_filter(convert, neg, neg->conversion_filters[conv_step].conversion_filter, log_ctx);
+                    if (ret < 0)
+                        return ret;
+                    else if (ret > 0) {
+                        count_merged += ret;
+                        break;
+                    } else if (conv_step < neg->nb_conversion_filters - 1) {
+                        AVFilterLink *inlink  = convert->inputs[0];
+                        AVFilterLink *outlink = convert->outputs[0];
+                        av_log(log_ctx, AV_LOG_VERBOSE,
+                               "Impossible to convert between the formats supported by the filter "
+                               "'%s' and the filter '%s', try another conversion filter.\n",
+                               link->src->name, link->dst->name);
+                        unsigned dstpad_idx = outlink->dstpad - outlink->dst->input_pads;
+                        converter_count--;
+                        /* re-hookup the link */
+                        inlink->dst                      = outlink->dst;
+                        inlink->dstpad                   = &outlink->dst->input_pads[dstpad_idx];
+                        outlink->dst->inputs[dstpad_idx] = inlink;
+                        if (outlink->outcfg.formats)
+                            ff_formats_changeref(&outlink->outcfg.formats,
+                                                 &inlink->outcfg.formats);
+                        if (outlink->outcfg.samplerates)
+                            ff_formats_changeref(&outlink->outcfg.samplerates,
+                                                 &inlink->outcfg.samplerates);
+                        if (outlink->outcfg.channel_layouts)
+                            ff_channel_layouts_changeref(&outlink->outcfg.channel_layouts,
+                                                         &inlink->outcfg.channel_layouts);
+                        /* remove the previous auto filter */
+                        convert->inputs[0]       = NULL;
+                        convert->outputs[0]->dst = NULL;
+                        avfilter_free(convert);
+                    } else {
+                        av_log(log_ctx, AV_LOG_ERROR,
+                               "Impossible to convert between the formats supported by the filter "
+                               "'%s' and the filter '%s'\n", link->src->name, link->dst->name);
+                        return AVERROR(ENOSYS);
+                    }
+                }
             }
-
-            /* if there is more than one auto filter, we may need another round
-             * to fully settle formats due to possible cross-incompatibilities
-             * between the auto filters themselves */
-            if (num_conv > 1)
-                goto retry;
         }
     }
 
diff --git a/libavfilter/formats.c b/libavfilter/formats.c
index 11a0f13ac6..df341160d8 100644
--- a/libavfilter/formats.c
+++ b/libavfilter/formats.c
@@ -401,14 +401,32 @@ static const AVFilterFormatsMerger mergers_audio[] = {
     },
 };
 
+static const AVFilterFormatsFilter filters_video[] = {
+    {
+        .conversion_filter = "scale",
+        .conversion_opts_offset = offsetof(AVFilterGraph, scale_sws_opts),
+    },
+};
+
+static const AVFilterFormatsFilter filters_audio[] = {
+    {
+        .conversion_filter = "aresample",
+        .conversion_opts_offset = offsetof(AVFilterGraph, aresample_swr_opts),
+    }
+};
+
 static const AVFilterNegotiation negotiate_video = {
     .nb_mergers = FF_ARRAY_ELEMS(mergers_video),
     .mergers = mergers_video,
+    .nb_conversion_filters = FF_ARRAY_ELEMS(filters_video),
+    .conversion_filters = filters_video,
 };
 
 static const AVFilterNegotiation negotiate_audio = {
     .nb_mergers = FF_ARRAY_ELEMS(mergers_audio),
     .mergers = mergers_audio,
+    .nb_conversion_filters = FF_ARRAY_ELEMS(filters_audio),
+    .conversion_filters = filters_audio,
 };
 
 const AVFilterNegotiation *ff_filter_get_negotiation(AVFilterLink *link)
diff --git a/libavfilter/formats.h b/libavfilter/formats.h
index 0c92ecad3f..36312e16ea 100644
--- a/libavfilter/formats.h
+++ b/libavfilter/formats.h
@@ -521,6 +521,11 @@ typedef struct AVFilterFormatMerger {
     unsigned conversion_opts_offset;
 } AVFilterFormatsMerger;
 
+typedef struct AVFilterFormatFilter {
+    const char *conversion_filter;
+    unsigned conversion_opts_offset;
+} AVFilterFormatsFilter;
+
 /**
  * Callbacks and properties to describe the steps of a format negotiation.
  *
@@ -609,6 +614,8 @@ typedef struct AVFilterFormatMerger {
 typedef struct AVFilterNegotiation {
     unsigned nb_mergers;
     const AVFilterFormatsMerger *mergers;
+    unsigned nb_conversion_filters;
+    const AVFilterFormatsFilter *conversion_filters;
 } AVFilterNegotiation;
 
 const AVFilterNegotiation *ff_filter_get_negotiation(AVFilterLink *link);
-- 
2.41.0.windows.1

